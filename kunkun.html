<!DOCTYPE html>
<html lang="zh-Hant">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KunKun Monitoring Dashboard</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Vue 3 CDN -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <!-- Axios CDN -->
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <!-- Chart.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
        .grid-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(7rem, 1fr));
            gap: 0.5rem;
        }

        .kv-k {
            font-size: 0.7rem;
            font-weight: lighter;
        }

        .kv-v {
            font-size: 0.8rem;
            font-weight: normal;
            color: #2d2d2d;
        }

        .operate-button {
            cursor: pointer;
        }

        .offline {
            opacity: 0.8;
            border-left: 2px solid #e49797;
        }

        .online {
            border-left: 2px solid #83dc6e;
        }

        .bg-success {
            background-color: #83dc6e;
        }

        #trendChart {
            min-height: 300px;
        }

        #modal-root {
            position: fixed;
            z-index: 9999;
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body>
    <div id="app"></div>

    <script>
        const { createApp, ref, reactive, computed, watch, onMounted } = Vue;

        const HOST = '';

        // Helper functions
        const BtoGB = (bytes) => (bytes / 1024 / 1024 / 1024).toFixed(2);
        const usagePercentage = (used, total) => ((used / total) * 100).toFixed(2);
        const formatTime = (timestamp) => new Date(timestamp * 1000).toLocaleTimeString();
        const isOutdated = (timestamp) => Math.floor(Date.now() / 1000) - timestamp > 1 * 60;

        // 定义需要渲染的字段，实际服务器返回的字段中有一些不适合直接展示
        const TITLES = {
            machine_Name: ['机器名', '', '服务器备注'],
            hostname: ['主机名', '', '当前服务器的主机名称'],
            uptimeDays: ['运行时间', '天', '服务器自上次启动以来的运行天数'],
            tasksInfo: ['进程 (运行中/全部)', '', '当前运行的进程数量与总进程数量'],
            loadAverages: ['负载', '', '系统在过去 1、5、15 分钟的平均负载'],
            memoryUsage: ['内存', '', '当前内存使用情况，已用/可用'],
            trafficInfo: ['总流量 (接收/发送)', 'G', '服务器自上次启动以来的网络总流量，包括接收和发送的数据量'],
            connectionInfo: ['连接数 (TCP/UDP)', '', '当前 TCP 和 UDP 连接数'],
            netTxSpeedKB: ['上传速度', 'K', '当前网络上传速度'],
            netRxSpeedKB: ['下载速度', 'K', '当前网络下载速度'],
            updateAt: ['更新时间', '', '数据最后更新时间'],
            cpu_num_cores: ['CPU 核心数', '', 'CPU 的核心数量'],
            cpu_delay_us: ['CPU 延迟', 'μs', 'CPU 处理任务的延迟时间'],
            cpu_us_percent: ['CPU 用户占用', '%', '用户进程占用的 CPU 百分比'],
            cpu_sy_percent: ['CPU 系统占用', '%', '系统内核占用的 CPU 百分比'],
            cpu_ni_percent: ['CPU 低优先级', '%', '低优先级进程占用的 CPU 百分比'],
            cpu_id_percent: ['CPU 空闲', '%', 'CPU 空闲时间的百分比'],
            cpu_wa_percent: ['CPU IO等待', '%', 'CPU 等待 I/O 操作的时间百分比'],
            cpu_hi_percent: ['CPU 硬件中断', '%', '硬件中断占用的 CPU 百分比'],
            cpu_st_percent: ['CPU 被宿主机占用', '%', '虚拟机被宿主机占用的 CPU 百分比'],
            rootDiskInfo: ['根目录空间', '', '根目录磁盘的使用情况，已用/可用'],
            disk_delay_us: ['磁盘延迟', 'ms', '根目录磁盘 I/O 操作的延迟时间'],
            readsPerSecond: ['读取次数', '', '根目录磁盘采样周期内的读取操作次数'],
            writesPerSecond: ['写入次数', '', '根目录磁盘采样周期内的写入操作次数'],
            avgReadLatency: ['平均读取延迟', 'ms', '根目录磁盘读取操作的平均延迟时间'],
            avgWriteLatency: ['平均写入延迟', 'ms', '根目录磁盘写入操作的平均延迟时间'],
            diskUtilization: ['磁盘利用率', '%', '根目录磁盘的使用率百分比'],
            weightedIoTimePercent: ['加权I/O时间', '%', '根目录磁盘 I/O 操作的加权时间百分比'],
        };

        const PercentageCircle = {
            props: ['percentage'],
            template: `
                <div class="inline-block align-middle mr-1" :title="percentage * 100 + '%'">
                    <svg class="w-4 h-4" viewBox="0 0 50 50">
                        <circle class="text-gray-200 stroke-current" stroke-width="7" fill="transparent" r="20" cx="25" cy="25" />
                        <circle class="text-blue-500 stroke-current" stroke-width="7" fill="transparent" r="20" cx="25" cy="25"
                            :stroke-dasharray="circumference" :stroke-dashoffset="offset"
                            style="transition: stroke-dashoffset 0.5s ease" />
                    </svg>
                </div>
            `,
            setup(props) {
                const radius = 20;
                const circumference = 2 * Math.PI * radius;
                const offset = computed(() => circumference * (1 - props.percentage));

                return {
                    circumference,
                    offset,
                };
            },
        };

        const TrendModal = {
            props: ['clientId', 'onClose'],
            setup(props) {
                const apiData = ref(null);
                const chartData = ref(null);
                const dataLevel = ref('seconds');
                const selectedKeys = ref(['load_1min']);
                const availableKeys = ref([]);

                const dataLevelOptions = [
                    { value: 'seconds', label: '最近一小时', title: '10秒递进' },
                    { value: 'minutes', label: '最近一天', title: '60秒递进' },
                    { value: 'hours', label: '最近一年', title: '60分钟递进' },
                ];

                const apiObjectKeys = {
                    uptime_s: ["运行时间", "秒", "系统运行的总时间（秒）"],
                    load_1min: ["负载-1分钟", "", "过去1分钟的系统平均负载"],
                    load_5min: ["负载-5分钟负载", "", "过去5分钟的系统平均负载"],
                    load_15min: ["负载-15分钟负载", "", "过去15分钟的系统平均负载"],
                    running_tasks: ["任务数-正在进行", "", "当前正在运行的任务数量"],
                    total_tasks: ["任务数-全部", "", "系统中总的任务数量"],
                    cpu_num_cores: ["CPU-核心数", "", "CPU的核心数量"],
                    cpu_delay_us: ["CPU-延迟", "μs", "CPU任务的延迟时间（微秒）"],
                    cpu_user: ["CPU-用户占用", "%", "用户空间占用的CPU百分比"],
                    cpu_system: ["CPU-系统占用", "%", "内核空间占用的CPU百分比"],
                    cpu_nice: ["CPU-低优先级", "%", "低优先级进程占用的CPU百分比"],
                    cpu_idle: ["CPU-空闲", "%", "CPU空闲时间的百分比"],
                    cpu_iowait: ["CPU-IO等待", "%", "CPU等待IO操作的时间百分比"],
                    cpu_irq: ["CPU-硬件中断", "%", "CPU处理硬中断的时间百分比"],
                    cpu_softirq: ["CPU-软件中断", "%", "CPU处理软中断的时间百分比"],
                    cpu_steal: ["CPU-被宿主机占用", "%", "虚拟CPU等待物理CPU的时间百分比"],
                    mem_really_used_mib: ["内存-真实已用", "Mib", "减去缓存和缓冲的内存占用大小（MiB）"],
                    mem_used_total_percent: ["内存-已用占比", "%", "真实内存使用量占比"],
                    mem_total_mib: ["内存-全部", "MiB", "系统总内存大小（MiB）"],
                    mem_free_mib: ["内存-空闲", "MiB", "系统空闲内存大小（MiB）"],
                    mem_used_mib: ["内存-已用", "MiB", "系统已用内存大小（MiB）"],
                    mem_buff_cache_mib: ["内存-缓存", "MiB", "用于缓存和缓冲的内存大小（MiB）"],
                    tcp_connections: ["连接数-TCP", "个", "当前TCP连接数量"],
                    udp_connections: ["连接数-UDP", "个", "当前UDP连接数量"],
                    default_interface_net_rx_bytes: ["流量-下载速度", "Bit", "当前开机期间默认网络接口接收的总字节数"],
                    default_interface_net_tx_bytes: ["流量-上传速度", "Bit", "当前开机期间默认网络接口发送的总字节数"],
                    disk_delay_us: ["磁盘-延迟", "ms", "磁盘IO操作的延迟时间（毫秒）"],
                    root_disk_total_kb: ["磁盘-根目录总空间", "KB", "根磁盘的总容量（KB）"],
                    root_disk_avail_kb: ["磁盘-根目录可用空间", "KB", "根磁盘的可用容量（KB）"],
                    reads_completed: ["磁盘-读取完成次数", "", "磁盘读取操作完成的次数"],
                    writes_completed: ["磁盘-写入完成次数", "", "磁盘写入操作完成的次数"],
                    reading_ms: ["磁盘-读取时间", "ms", "磁盘读取操作的总时间（毫秒）"],
                    writing_ms: ["磁盘-写入时间", "ms", "磁盘写入操作的总时间（毫秒）"],
                    iotime_ms: ["磁盘-IO时间", "ms", "磁盘IO操作的总时间（毫秒）"],
                    ios_in_progress: ["磁盘-进行中的IO操作", "", "当前正在进行的磁盘IO操作数量"],
                    weighted_io_time: ["磁盘-加权IO时间", "ms", "加权后的磁盘IO操作时间（毫秒）"],
                };

                const fetchHistoryData = async () => {
                    try {
                        const endpoint = `/status/${dataLevel.value}`;
                        const response = await axios.get(`${HOST}${endpoint}`, {
                            params: { client_id: props.clientId },
                        });

                        const data = response.data.reverse();
                        data.forEach(item => {
                            calculateAndNormalizeKeys(item, ["cpu_user", "cpu_system", "cpu_nice", "cpu_idle", "cpu_iowait", "cpu_irq", "cpu_softirq", "cpu_steal"]);
                            calculateUsedMemParcent(item);
                        });

                        apiData.value = data;

                        if (data && data.length > 0) {
                            const keys = Object.keys(data[0]).filter(
                                key => key !== 'client_id' && key !== 'timestamp' && apiObjectKeys.hasOwnProperty(key)
                            );
                            availableKeys.value = keys;
                            if (!selectedKeys.value) {
                                selectedKeys.value = ['load_1min'];
                            }
                        }
                    } catch (error) {
                        console.error('Error fetching history data:', error);
                    }
                };

                const handleDataLevelChange = (event) => {
                    dataLevel.value = event.target.value;
                };

                const handleSelectedKeysChange = (event) => {
                    const selected = Array.from(event.target.selectedOptions, option => option.value);
                    selectedKeys.value = selected;
                };

                watch([dataLevel, selectedKeys], () => {
                    if (apiData.value && apiData.value.length > 0) {
                        const labels = apiData.value.map(item => formatTimestamp(item.timestamp * 1000));

                        const CHART_COLORS = {
                            red: 'rgba(255, 99, 132, 0.8)',
                            orange: 'rgba(255, 159, 64, 0.8)',
                            yellow: 'rgba(255, 205, 86, 0.8)',
                            green: 'rgba(75, 192, 192, 0.8)',
                            blue: 'rgba(54, 162, 235, 0.8)',
                            purple: 'rgba(153, 102, 255, 0.8)',
                        };

                        const datasets = selectedKeys.value.map((key, index) => ({
                            label: key,
                            data: apiData.value.map(item => item[key]),
                            borderColor: Object.values(CHART_COLORS)[index % Object.keys(CHART_COLORS).length],
                            fill: false,
                            pointStyle: false,
                            borderWidth: 1,
                        }));

                        chartData.value = { labels, datasets };
                    }
                });

                onMounted(() => {
                    fetchHistoryData();
                });

                return {
                    apiData,
                    chartData,
                    dataLevel,
                    selectedKeys,
                    availableKeys,
                    dataLevelOptions,
                    apiObjectKeys,
                    handleDataLevelChange,
                    handleSelectedKeysChange,
                };
            },
            template: `
                <div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4">
                    <div class="bg-white rounded-lg p-2 py-4 w-full max-w-4xl">
                        <div class="flex justify-between items-center mb-4">
                            <h2 class="text-sm font-bold">统计数据</h2>
                            <button @click="onClose" class="text-sm text-gray-500 hover:text-gray-700">Close</button>
                        </div>
                        <div class="grid grid-cols-2 gap-4 mb-4">
                            <div>
                                <select v-model="dataLevel" @change="handleDataLevelChange" class="text-sm w-full p-2 border rounded">
                                    <option v-for="option in dataLevelOptions" :key="option.value" :value="option.value" :title="option.title">
                                        {{ option.label }}
                                    </option>
                                </select>
                            </div>
                            <div v-if="availableKeys.length > 0">
                                <select v-model="selectedKeys" @change="handleSelectedKeysChange" class="text-sm w-full p-2 border rounded" multiple>
                                    <option v-for="key in availableKeys" :key="key" :value="key" :title="apiObjectKeys[key][2]">
                                        {{ apiObjectKeys[key][0] }}
                                    </option>
                                </select>
                            </div>
                        </div>
                        <div class="relative" style="min-height: 350px">
                            <canvas id="trendChart"></canvas>
                        </div>
                    </div>
                </div>
            `,
        };

        const Server = {
            props: ['server', 'isExpanded', 'onToggleExpand', 'selectedFields', 'onFieldSelection'],
            setup(props) {
                const showTrendModal = ref(false);

                const KeyValue = {
                    props: ['k', 'v'],
                    template: `
                        <div>
                            <span class="kv-k text-gray-400 text-xs" :title="TITLES[k][2]">{{ TITLES[k][0] }}</span>
                            <div class="kv-v text-gray-700">{{ v }} {{ TITLES[k][1] }}</div>
                        </div>
                    `,
                };

                return {
                    showTrendModal,
                    KeyValue,
                };
            },
            template: `
                <div :class="['bg-white rounded-lg shadow-sm', server.isOffline ? 'offline' : 'online']">
                    <div class="p-3 cursor-pointer hover:bg-gray-50 rounded-lg transition-colors" @click="onToggleExpand">
                        <div class="grid-container text-sm">
                            <KeyValue v-for="key in selectedFields" :key="key" :k="key" :v="server[key]" />
                        </div>
                    </div>
                    <div v-if="isExpanded" class="p-3 border-t border-gray-200">
                        <div class="grid-container text-sm">
                            <KeyValue v-for="key in Object.keys(TITLES).filter(key => TITLES.hasOwnProperty(key) && !selectedFields.includes(key))" :key="key" :k="key" :v="server[key]" />
                            <div>
                                <span class="kv-k text-gray-400 text-xs">操作</span>
                                <div class="operate-button" @click="showTrendModal = true">统计</div>
                            </div>
                        </div>
                    </div>
                    <TrendModal v-if="showTrendModal" :clientId="server.client_id" @onClose="showTrendModal = false" />
                </div>
            `,
        };
        const App = {
            setup() {
                const servers = ref([]);
                const expandedStates = reactive({});
                const showFieldSelector = ref(false);
                const selectedFields = ref(JSON.parse(localStorage.getItem('selectedFields')) || ['hostname', 'loadAverages', 'memoryUsage']);

                const prevServersRef = ref({});
                const renderServers = ref({});

                const handleFieldSelection = (key) => {
                    if (selectedFields.value.includes(key)) {
                        selectedFields.value = selectedFields.value.filter(field => field !== key);
                    } else {
                        selectedFields.value.push(key);
                    }
                    localStorage.setItem('selectedFields', JSON.stringify(selectedFields.value));
                };

                const calculateCpuPercentages = (currentCpu, prevCpu) => {
                    const diff = {
                        cpu_us: currentCpu.cpu_user - (prevCpu.cpu_user || 0),
                        cpu_sy: currentCpu.cpu_system - (prevCpu.cpu_system || 0),
                        cpu_ni: currentCpu.cpu_nice - (prevCpu.cpu_nice || 0),
                        cpu_id: currentCpu.cpu_idle - (prevCpu.cpu_idle || 0),
                        cpu_wa: currentCpu.cpu_iowait - (prevCpu.cpu_iowait || 0),
                        cpu_hi: currentCpu.cpu_irq - (prevCpu.cpu_irq || 0),
                        cpu_st: currentCpu.cpu_steal - (prevCpu.cpu_steal || 0),
                    };

                    const total = Object.values(diff).reduce((sum, value) => sum + value, 0);

                    if (total === 0) {
                        return {
                            cpu_us_percent: prevCpu.cpu_us_percent || '0.00',
                            cpu_sy_percent: prevCpu.cpu_sy_percent || '0.00',
                            cpu_ni_percent: prevCpu.cpu_ni_percent || '0.00',
                            cpu_id_percent: prevCpu.cpu_id_percent || '0.00',
                            cpu_wa_percent: prevCpu.cpu_wa_percent || '0.00',
                            cpu_hi_percent: prevCpu.cpu_hi_percent || '0.00',
                            cpu_st_percent: prevCpu.cpu_st_percent || '0.00',
                        };
                    }

                    return {
                        cpu_us_percent: ((diff.cpu_us / total) * 100).toFixed(2),
                        cpu_sy_percent: ((diff.cpu_sy / total) * 100).toFixed(2),
                        cpu_ni_percent: ((diff.cpu_ni / total) * 100).toFixed(2),
                        cpu_id_percent: ((diff.cpu_id / total) * 100).toFixed(2),
                        cpu_wa_percent: ((diff.cpu_wa / total) * 100).toFixed(2),
                        cpu_hi_percent: ((diff.cpu_hi / total) * 100).toFixed(2),
                        cpu_st_percent: ((diff.cpu_st / total) * 100).toFixed(2),
                    };
                };

                const calculateNetworkSpeed = (currentNet, prevNet) => {
                    const timeDiff = currentNet.timestamp - prevNet.timestamp;

                    const diffRx = currentNet.default_interface_net_rx_bytes - (prevNet.default_interface_net_rx_bytes || currentNet.default_interface_net_rx_bytes);
                    const diffTx = currentNet.default_interface_net_tx_bytes - (prevNet.default_interface_net_tx_bytes || currentNet.default_interface_net_tx_bytes);

                    if (diffRx === 0 && diffTx === 0) {
                        return {
                            netRxSpeedKB: prevNet.netRxSpeedKB || 0.00,
                            netTxSpeedKB: prevNet.netTxSpeedKB || 0.00,
                        };
                    }

                    return {
                        netRxSpeedKB: (diffRx / 1024 / timeDiff).toFixed(2),
                        netTxSpeedKB: (diffTx / 1024 / timeDiff).toFixed(2),
                    };
                };

                const processIOData = (prevData, currentData) => {
                    const timeDiff = currentData.timestamp - prevData.timestamp;

                    const readsPerSecond = ((currentData.reads_completed - prevData.reads_completed) / timeDiff).toFixed(2);
                    const writesPerSecond = ((currentData.writes_completed - prevData.writes_completed) / timeDiff).toFixed(2);

                    const avgReadLatency = (currentData.reading_ms / currentData.reads_completed).toFixed(2);
                    const avgWriteLatency = (currentData.writing_ms / currentData.writes_completed).toFixed(2);

                    const diskUtilization = ((currentData.iotime_ms - prevData.iotime_ms) / (timeDiff * 1000000)).toFixed(2);

                    const weightedIoTimePercent = ((currentData.weighted_io_time / currentData.iotime_ms)).toFixed(2);

                    return {
                        readsPerSecond,
                        writesPerSecond,
                        avgReadLatency,
                        avgWriteLatency,
                        diskUtilization,
                        weightedIoTimePercent,
                    };
                };

                const fetchData = async () => {
                    try {
                        const response = await axios.get(`${HOST}/status/latest`);
                        const newServers = response.data;

                        newServers.forEach(server => {
                            server.mem_really_used_mib = (server.mem_total_mib - (server.mem_free_mib + server.mem_buff_cache_mib)).toFixed(2);

                            const machineId = server.machine_id;
                            const prevServer = prevServersRef.value[machineId] || {};
                            const renderServer = renderServers.value[machineId] || {};

                            if (JSON.stringify(server) === JSON.stringify(prevServer)) {
                                return;
                            } else {
                                prevServersRef.value[machineId] = server;
                            }

                            const cpuPercentages = calculateCpuPercentages(server, prevServer);
                            const networkSpeed = calculateNetworkSpeed(server, prevServer);
                            const uptimeDays = `${Math.floor(server.uptime_s / 3600 / 24)}`;

                            renderServers.value[machineId] = {
                                ...server,
                                ...cpuPercentages,
                                ...networkSpeed,
                                ...processIOData(prevServer, server),

                                loadAverages: `${server.load_1min}/${server.load_5min}/${server.load_15min}`,
                                updateAt: formatTime(server.timestamp),
                                memoryUsage: {
                                    used: (server.mem_really_used_mib / 1024).toFixed(2),
                                    total: (server.mem_total_mib / 1024).toFixed(2),
                                },
                                tasksInfo: `${server.running_tasks}/${server.total_tasks}`,
                                trafficInfo: `${BtoGB(server.default_interface_net_rx_bytes)}/${BtoGB(server.default_interface_net_tx_bytes)}`,
                                connectionInfo: `${server.tcp_connections}/${server.udp_connections}`,
                                rootDiskInfo: {
                                    used: BtoGB((server.root_disk_total_kb - server.root_disk_avail_kb) * 1024),
                                    total: BtoGB(server.root_disk_total_kb * 1024),
                                },
                                isOffline: isOutdated(server.timestamp), // 使用 isOutdated 函数
                                uptimeDays: uptimeDays,
                            };
                        });

                        servers.value = Object.values(renderServers.value);
                    } catch (error) {
                        console.error('Error fetching data:', error);
                    }
                };

                onMounted(() => {
                    fetchData();
                    const interval = setInterval(fetchData, 1000);
                    return () => clearInterval(interval);
                });

                const toggleExpand = (machineId) => {
                    expandedStates[machineId] = !expandedStates[machineId];
                };

                return {
                    servers,
                    expandedStates,
                    showFieldSelector,
                    selectedFields,
                    handleFieldSelection,
                    toggleExpand,
                };
            },
            template: `
        <div class="min-h-screen bg-gray-100 p-4">
            <h1 class="text-xl font-bold mb-4 text-center">KunKun Server Monitor</h1>
            <div class="space-y-2">
                <div class="p-3 py-0 cursor-pointer rounded-lg transition-colors flex items-center justify-between text-sm">
                    <p>Online {{ servers.filter(server => !isOutdated(server.timestamp)).length }}/{{ servers.length }}</p>
                    <button class="p-1 text-gray-500 hover:text-gray-700" @click="showFieldSelector = true">⚙️</button>
                </div>
                <Server
                    v-for="server in servers"
                    :key="server.machine_id"
                    :server="server"
                    :isExpanded="expandedStates[server.machine_id] || false"
                    :selectedFields="selectedFields"
                    @onToggleExpand="toggleExpand(server.machine_id)"
                    @onFieldSelection="handleFieldSelection"
                />
            </div>
            <div v-if="showFieldSelector" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center">
                <div class="bg-white p-4 rounded-lg shadow-lg">
                    <div class="py-2">选择优先显示字段</div>
                    <div class="grid grid-cols-3 gap-2 p-2">
                        <label v-for="key in Object.keys(TITLES)" :key="key" class="flex items-center text-gray-400 text-xs">
                            <input
                                type="checkbox"
                                :checked="selectedFields.includes(key)"
                                @change="handleFieldSelection(key)"
                            />
                            <span class="ml-2">{{ TITLES[key][0] }}</span>
                        </label>
                    </div>
                    <button
                        class="mt-4 py-2 px-4 text-xs inline-flex items-center rounded-md bg-green-50 px-2 py-1 text-xs font-medium text-green-700 ring-1 ring-inset ring-green-600/20"
                        @click="showFieldSelector = false"
                    >
                        确认
                    </button>
                </div>
            </div>
        </div>
    `,
        };

        const app = createApp(App);
        app.component('Server', Server);
        app.component('TrendModal', TrendModal);
        app.component('PercentageCircle', PercentageCircle);
        app.mount('#app');
    </script>
</body>

</html>
